# import 
#     asyncdispatch,
#     asyncfile,
#     os,
#     variant,
#     streams,
#     productDomain,
#     db_sqlite

# # Changes file log
# const CHANGES_FILE = "changes.log"
# # Storage file
# const STORAGE_FILE = "storage.dat"

# # Command to add class
# const ADD_CLASS_COMMAND = 1
# # Command to add instance
# const ADD_INSTANCE_COMMAND = 2
# # Command to add class field
# const ADD_CLASS_FIELD_COMMAND = 3
# # Command to add instance field
# const ADD_INSTANCE_FIELD_COMMAND = 4
# # Command to set field value
# const SET_VALUE_COMMAND = 5

# #############################################################################################
# # Writer

# type Writer = ref object of RootObj
#     stream : StringStream
#     len : uint32

# proc newWriter() : Writer =
#     result = Writer()
#     result.stream = newStringStream()
#     result.len = 0

# proc data(this : Writer) : string =
#     # Return data
#     this.stream.setPosition(0)    
#     result = this.stream.readStr(int (this.len))

# proc writeUint64(this : Writer, value : uint64) : void =
#     # Write uint64 without type    
#     this.stream.write(uint64 value)
#     this.len += 8

# proc writeUint8(this : Writer, value : uint8) : void =
#     # Write uint8
#     this.stream.write(uint8 value)
#     this.len += 1

# proc writeInt32(this : Writer, value : int32) : void =
#     # Write int32
#     this.stream.write(int32 value)
#     this.len += 4

# proc writeFloat64(this : Writer, value : float64) : void =
#     # Write float64
#     this.stream.write(float64 value)
#     this.len += 8

# proc writeString(this : Writer, value : string) : void =
#     # Write string
#     # if writeType:
#     #     this.stream.write(uint8 STRING)
#     this.stream.write(uint32 value.len)
#     this.stream.write(value)
#     this.len += uint32(value.len + 4)

# #############################################################################################
# # Reader
# type
#     Reader = ref object of RootObj
#         file : AsyncFile

# proc newReader(file : AsyncFile) : Reader =
#     # Create new reader
#     result = Reader()
#     result.file = file

# proc readString(this : Reader, len : uint32) : Future[string] {.async.} =
#     # Read string
#     result = await this.file.read(int len)

# proc readUint8(this : Reader) : Future[uint8] {.async.} = 
#     let str = await this.file.read(1)
#     result = uint8 str[0]

# proc readUint32(this : Reader) : Future[uint32] {.async.} = 
#     # Read string
#     let str = await this.file.read(4)
#     result = ((uint8 str[0]) shl 24) + ((uint8 str[1]) shl 16) + ((uint8 str[2]) shl 8) + (uint8 str[0])

# proc readUint64(this : Reader) : Future[uint64] {.async.} = 
#     # Read string
#     let str = await this.file.read(8)
#     result = (uint64(uint8 str[7]) shl 56) + 
#              (uint64(uint8 str[6]) shl 48) + 
#              (uint64(uint8 str[5]) shl 40) + 
#              (uint64(uint8 str[4]) shl 32) + 
#              (uint64(uint8 str[3]) shl 24) + 
#              (uint64(uint8 str[2]) shl 16) + 
#              (uint64(uint8 str[1]) shl 8) + 
#              uint64(uint8 str[0])

# #############################################################################################
# type     
#     LogRecord = ref object of RootObj

#     # Entity to store
#     StoreEntity* = ref object of LogRecord
#         id* : UniqueId
#         name* : string

#     # Object for add class command
#     AddClass* = ref object of LogRecord
#         id* : UniqueId
#         parent* : UniqueId
#         name* : string

#     # Object for change field command
#     AddField* = ref object of LogRecord
#         id* : UniqueId
#         parent* : UniqueId
#         name* : string

#     # Object for change field command
#     FieldValue* = ref object of LogRecord
#         id* : UniqueId
#         valueType* : ValueType
#         value* : Variant

# type StorageGlobal = ref object
#     db : DbConn             # Database connection

# var storageGlobal {.threadvar.} : StorageGlobal    

# proc newStorageGlobal() : StorageGlobal =
#     # Create new storage module
#     result = StorageGlobal()    

# proc logEntity*(entity : StoreEntity) {.async.} =
#     # Full log of entity
#     var file = openAsync("database.log", fmAppend)
#     var writer = newWriter()
#     writer.writeUint64(entity.id)
#     writer.writeString(entity.name)
#     await file.write(writer.data)
#     file.close()

# proc logAddClass*(entity : AddClass) {.async.} = 
#     # Log entity creating
#     var file = openAsync("changes.log", fmAppend)
#     var writer = newWriter()
#     writer.writeUint8(ADD_CLASS_COMMAND)
#     writer.writeUint64(entity.id)
#     writer.writeUint64(entity.parent)
#     writer.writeString(entity.name)
#     await file.write(writer.data)
#     file.close()

# # proc logAddField*(field : AddField) {.async.} =
# #     # Log field add
# #     var file = openAsync(CHANGES_FILE, fmAppend)
# #     var writer = newWriter()
# #     writer.writeUint8(ADD_FIELD_COMMAND)
# #     writer.writeUint64(field.id)
# #     writer.writeUint64(field.parent)
# #     writer.writeString(field.name)
# #     await file.write(writer.data)
# #     file.close()

# proc logSetValue*(value : FieldValue) {.async.} =
#     # Log set field value
#     var file = openAsync(CHANGES_FILE, fmAppend)
#     var writer = newWriter()
#     writer.writeUint8(SET_VALUE_COMMAND)
#     writer.writeUint8(uint8 value.valueType)

#     case value.valueType
#     of INT: writer.writeInt32(value.value.get(int32))
#     of FLOAT: writer.writeFloat64(value.value.get(float64))
#     of STRING: writer.writeString(value.value.get(string))
#     else: raise newException(Exception, "Wrong type")

#     await file.write(writer.data)
#     file.close()

# proc processAddClass(data : Reader) : Future[AddClass] {.async.} =
#     result = AddClass()
#     result.id = await data.readUint64()    
#     result.parent = await data.readUint64()
#     let len = await data.readUint32()
#     result.name = await data.readString(len)

# # proc processAddField(data : Reader) : Future[AddField] {.async.} =    
# #     result = AddField()
# #     result.id = await data.readUint64()
# #     result.parent = await data.readUint64()
# #     let len = await data.readUint32()
# #     result.name = await data.readString(len)

# # proc processSetValue(data : Reader) : Future[FieldValue] {.async.} =
# #     result = FieldValue()           
# #     result.valueType = ValueType(await data.readUint8())
# #     case result.valueType
# #     of INT: result.value = newVariant(int32(await data.readUint32()))
# #     #of FLOAT: result.value = newVariant(int(await data.readFloat64()))
# #     of STRING: 
# #         let len = await data.readUint32()
# #         result.value = newVariant(await data.readString(len))
# #     else:
# #         raise newException(Exception, "Wrong type")    

# proc processRecord(reader : Reader) : Future[LogRecord] {.async.} = 
#     # Process record
#     let recType = await reader.readUint8()
#     case recType
#     of ADD_CLASS_COMMAND: return await processAddClass(reader)
#     # of ADD_FIELD_COMMAND: return await processAddField(reader)
#     # of SET_VALUE_COMMAND: return await processSetValue(reader)
#     else: raise newException(Exception, "Wrong record")

# iterator iterateLog() : LogRecord = 
#     # Iterate log file
#     var file = openAsync(CHANGES_FILE, fmRead)
#     let reader = newReader(file)

#     try:
#         while true:
#             yield waitFor processRecord(reader)
#     except:
#         discard
#         #echo getCurrentExceptionMsg()
    
#     file.close()

# proc initDatabase() =
#     # Init database
#     if not os.existsFile(STORAGE_FILE):
#         echo "Init database"
#         storageGlobal.db = open(STORAGE_FILE, "user", "password", "storage")
#         storageGlobal.db.exec(sql("""
#         CREATE TABLE classes (
#             id          INTEGER PRIMARY KEY,
#             parent      INTEGER,
#             name        VARCHAR(100) NOT NULL
#         );
#         CREATE TABLE instances (
#             id          INTEGER PRIMARY KEY,
#             parent      INTEGER,
#             name        VARCHAR(100) NOT NULL
#         );
#         """))
#     else:
#         storageGlobal.db = open(STORAGE_FILE, "user", "password", "storage")

# proc processAddClass(entity : AddClass) : void =
#     let db = storageGlobal.db
#     db.exec(sql("INSERT INTO classes(id,parent,name) VALUES(?,?,?)"), entity.id, entity.parent, entity.name)

# proc processLog() =
#     # Load log and store it to database
#     if not os.existsFile(CHANGES_FILE): return

#     for record in iterateLog():
#         if record of AddClass:
#             let rec = AddClass(record)
#             processAddClass(rec)
#         if record of AddField:
#             let rec = AddField(record)
#         if record of FieldValue:
#             let rec = FieldValue(record)

# proc removeLog() =
#     # Remove log file
#     os.removeFile(CHANGES_FILE)

# iterator iterateClasses*() : auto =
#     # Iterate entities from database
#     for row in storageGlobal.db.fastRows(sql("SELECT * FROM classes")):
#         yield row


# proc init*() : void =
#     storageGlobal = newStorageGlobal()
#     initDatabase()
#     processLog()
#     removeLog()